/**
 * UPDATE CHO FILE app.js
 * Thay th·∫ø function performReading() v·ªõi code d∆∞·ªõi ƒë√¢y
 */

// ==================== UPDATE FUNCTION performReading ====================

async performReading() {
    const question = document.getElementById('questionInput').value.trim();
    const sig = document.getElementById('sigInput').value.trim();
    
    // Show shuffle animation
    document.getElementById('shuffleAnimation').style.display = 'block';
    document.getElementById('loadingState').style.display = 'none';
    document.getElementById('resultsSection').style.display = 'none';
    
    // Wait for shuffle animation (3 seconds)
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Hide shuffle, show loading
    document.getElementById('shuffleAnimation').style.display = 'none';
    document.getElementById('loadingState').style.display = 'block';
    
    try {
        // ====== THAY ƒê·ªîI CH√çNH: G·ªçi endpoint m·ªõi ======
        const response = await fetch('/api/tarot/reading', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                spread: this.currentSpread,
                question: question
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Unknown error');
        }
        
        // Store current reading
        this.currentReading = {
            text: result.text,
            spread: this.currentSpread,
            question: question,
            timestamp: Date.now(),
            cardData: result.cards  // Cards v·ªõi URLs
        };
        
        // Display results
        this.displayResults(result.text, result.cards);
        
        console.log(`‚úÖ Reading completed in ${result.processing_time}s`);
        
    } catch (error) {
        console.error('Reading error:', error);
        alert(`C√≥ l·ªói x·∫£y ra: ${error.message}\n\nVui l√≤ng th·ª≠ l·∫°i ho·∫∑c ki·ªÉm tra:\n- Backend ƒëang ch·∫°y (port 5000)\n- Langflow ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh trong .env`);
    } finally {
        document.getElementById('loadingState').style.display = 'none';
    }
}

// ==================== UPDATE FUNCTION displayResults ====================

displayResults(text, cardData = null) {
    console.log('=== displayResults ===');
    console.log('Text length:', text ? text.length : 0);
    console.log('Card data:', cardData);
    
    // Display cards v·ªõi URLs t·ª´ backend
    if (cardData && cardData.length > 0) {
        console.log('Using card data from backend');
        this.displayCards(cardData);
    } else {
        console.log('No card data provided');
        this.displayCards([]);
    }
    
    // Display text content
    this.displayReadingContent(text);
    
    // Show results section
    document.getElementById('resultsSection').style.display = 'block';
    
    // Scroll to results
    document.getElementById('resultsSection').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
    });
}

// ==================== UPDATE FUNCTION displayCards ====================

displayCards(cards) {
    const container = document.getElementById('cardsDisplay');
    container.innerHTML = '';

    if (!cards || cards.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Kh√¥ng c√≥ th√¥ng tin l√° b√†i</p>';
        return;
    }

    // Display card images
    cards.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'tarot-card-image-only';
        
        // cardData t·ª´ backend format: {name: "...", url: "..."}
        const imageUrl = card.url || card.imageUrl || '';
        const cardName = card.name || `Card ${index + 1}`;
        
        cardEl.innerHTML = `
            <div class="card-image-wrapper">
                <img 
                    src="${imageUrl}" 
                    alt="${this.escapeHtml(cardName)}" 
                    class="card-image"
                    onerror="this.src='https://via.placeholder.com/250x400/7B68EE/FFFFFF?text=Tarot+Card'"
                >
            </div>
        `;
        
        container.appendChild(cardEl);
    });
}

// ==================== UPDATE FUNCTION displayReadingContent ====================

displayReadingContent(text) {
    const container = document.getElementById('resultsContent');
    container.innerHTML = '';
    
    if (!text) {
        container.innerHTML = '<p>Kh√¥ng c√≥ n·ªôi dung gi·∫£i nghƒ©a</p>';
        return;
    }
    
    // Split by paragraphs v√† format
    const paragraphs = text.split('\n\n');
    
    let conclusionFound = false;
    
    paragraphs.forEach(para => {
        if (!para.trim()) return;
        
        const paraEl = document.createElement('div');
        
        // Check if conclusion
        if (para.toLowerCase().includes('k·∫øt lu·∫≠n') && !conclusionFound) {
            paraEl.className = 'conclusion-section';
            conclusionFound = true;
            
            const title = document.createElement('h3');
            title.className = 'result-title';
            title.innerHTML = '<span>üîÆ</span> K·∫øt Lu·∫≠n';
            
            const content = document.createElement('p');
            content.className = 'result-text';
            // Remove "K·∫øt lu·∫≠n:" from text
            const cleanText = para.replace(/\*?\*?k·∫øt lu·∫≠n:?\*?\*?/i, '').trim();
            content.innerHTML = this.escapeHtml(cleanText);
            
            paraEl.appendChild(title);
            paraEl.appendChild(content);
        } else {
            paraEl.className = 'result-section';
            
            const p = document.createElement('p');
            p.className = 'result-text';
            p.innerHTML = this.escapeHtml(para);
            
            paraEl.appendChild(p);
        }
        
        container.appendChild(paraEl);
    });
}

// ==================== NOTES ====================

/*
THAY ƒê·ªîI CH√çNH:

1. performReading() - G·ªçi endpoint m·ªõi:
   OLD: POST /api/langflow/<spread>
   NEW: POST /api/tarot/reading
   
   Response format:
   {
       "success": true,
       "text": "AI reading text...",
       "cards": [
           {"name": "The Fool", "url": "https://..."},
           {"name": "The Magician", "url": "https://..."}
       ],
       "card_count": 3,
       "processing_time": 3.45
   }

2. displayResults() - ƒê∆°n gi·∫£n h∆°n:
   - Kh√¥ng c·∫ßn parse text ƒë·ªÉ extract URLs
   - Backend ƒë√£ x·ª≠ l√Ω t·∫•t c·∫£
   - Ch·ªâ vi·ªác display

3. displayCards() - Support format m·ªõi:
   - card.url (t·ª´ backend m·ªõi)
   - card.imageUrl (t·ª´ code c≈©, fallback)

4. displayReadingContent() - C·∫£i thi·ªán format:
   - T·ª± ƒë·ªông detect "K·∫øt lu·∫≠n"
   - Format ƒë·∫πp h∆°n

5. Error handling t·ªët h∆°n:
   - Show message h·ªØu √≠ch h∆°n cho user
   - H∆∞·ªõng d·∫´n debug
*/

// ==================== TESTING ====================

/*
Test trong browser console:

// Test API
fetch('/api/tarot/reading', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
        spread: 'three',
        question: 'Test t·ª´ browser'
    })
})
.then(r => r.json())
.then(d => console.log(d))

// Expected output:
{
    "success": true,
    "text": "...",
    "cards": [...],
    "processing_time": 3.45
}
*/

